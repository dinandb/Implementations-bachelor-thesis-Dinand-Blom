## Required: 

- SageMath 9.5+ (sudo apt install sagemath or sudo apt install sage, available for most major linux distributions, for ubuntu: only Ubuntu 18.04, 20.04, 22.04 supported)

- Python 3

## Syntax for tensors in python using sage

For experimental purposes of this thesis, python was used. To do calculations with tensors, like the tensordot operation, we use the *numpy* function *tensordot*.
Indeed, generating a random tensor $T$ and vector $v$, we can verify that

`[[sum([T[i,j,k] * u[i] for i in range(n)]) for k in range(n)] for j in range(n)]`

and 

`numpy.tensordot(T, u, axes=(0,0))`

give the same matrix, for any tensor $T$, vector $u$.
To ensure that these operations respect field logic, we will use the useful and extensive built-in functionalities and objects given by the python extension *sage*.
For creating random $n^3$ tensors we use

<pre>
def random_tensor(n):
   return np.array([[[F.random_element() for _ in range(n)] for _ in range(n)] for _ in range(n)])
</pre>

where $F$ is a sage Galois Field object of size $q$, for $q$ some prime power, created as follows:

`F = GF(q)`

all sage functionalities can be imported as follows:

`from sage import *`

For random matrices and vectors we have similar functions. For tensor equality we have a function that checks that all entries of both tensors are equal.
# Constructing new tensors
In the case where we were given an $n^3$ tensor $C$ and a triplet of matrices $(A,B,M)$, and wanted to construct a new tensor $D$ such that $(C &rarr; D) = (A,B,M)$ we used the following definition given in section 2.2.

$$D[j] = \sum_{i=1}^n A[i,j]\cdot B^T\cdot C[i] \cdot M$$

In python - using *sage* and *numpy*, this is written as
<pre>
D = np.array([ np.array(sum([ A[i,j]*B.T*Matrix(C[i,:,:])*M for i in range(n)])) for j in range(n)], dtype=object).reshape(C.shape)
</pre>
In section 2.2 we proved that this construction implies the equality above.

## Showing vulnerability of sending both transformations simultaneously
<p> In the last paragraph of section 2.3.1, we claim that sending both transformations simultaneously compromises the secret matrices $(A,B,C)$ after only one iteration. We will now show this attack in practice. <br>
First, we create a random tensor $C$, and random matrices $A,B,M,N,E,F$. (In an actual application, $(N,E,F)$ are of course generated by the algorithm for building the transformations from the representing vector, but for this attack that does not matter.) We use $M,N$ instead of $C,D$, since in the program, these names are reserved for the tensors of interest.</p>
Next, we create $D, C'$ from $C$:

```
sage: D = new_tensor_from_tensor_and_isomorphism(C,A,B,M)
sage: C_prime = new_tensor_from_tensor_and_isomorphism(C,N,E,F)
```

<p>Now, we have $(C &rarr; C') = (A,B,M)$ and $(C &rarr; D') = (N,E,F)$ <br>
From this it follows that $D &rarr; C' = (N,E,F) \circ (A,B,M)^{-1} = (NA^{-1}, EB^{-1}, FM^{-1})$.<br>
We want to show that if we send both $(N,E,F)$ and $(NA^{-1}, EB^{-1}, FM^{-1})$, the secret matrices are compromised. Note that sending the actual transformation matrices is no different than sending the corank1 point which the attacker can use to derive the transformation matrices. </p>


$$
\begin{split}
(NA^{-1}, EB^{-1}, FM^{-1})^{-1}\circ(N,E,F) &= ((NA^{-1})^{-1}, (EB^{-1})^{-1}, (FM^{-1})^{-1})\circ(N,E,F)\\
&= (AN^{-1}, BE^{-1}, MF^{-1})\circ(N,E,F)\\
&= (AN^{-1}N, BE^{-1}E, MF^{-1}F)\\
&= (A, B, C)
\end{split}
$$

$$
\begin{aligned}
(NA^{-1}, EB^{-1}, FM^{-1})^{-1}\circ(N,E,F) 
  &= ((NA^{-1})^{-1}, (EB^{-1})^{-1}, (FM^{-1})^{-1})\circ(N,E,F) \\
  &= (AN^{-1}, BE^{-1}, MF^{-1})\circ(N,E,F) \\
  &= (AN^{-1}N, BE^{-1}E, MF^{-1}F) \\
  &= (A, B, C)
\end{aligned}
$$

by lemma \ref{lem:transinv} and \ref{lem:transcomp} from the research chapter. So, we already know that sending both transformations compromises the secret transformation.
Now, we show it experimentally:
```
# we are the attacker
# we have received (N,E,F), (P=NA^(-1), Q=EB^(-1), R=FM^(-1))
sage: A_attack = P^(-1)*N
sage: B_attack = Q^(-1)*E
sage: C_attack = R^(-1)*F
# we attempt to construct D with tensor C, matrices (A_attack, B_attack, C_attack)
# if it indeed is D, then we have shown that the secret matrices are compromised
sage: D_attack = new_tensor_from_tensor_and_isomorphism(C, A_attack, B_attack, C_attack)
sage: tensor_equality(D, D_attack)
True
```

Note that sending both transformations simultaneously is also not a good idea for a secondary reason. Namely, sending both transformations probably means we send the vector $u$ that is a corank1 point of $C$, and the vector $A^{-1}u$, that is a corank1 point of $D$. This gives the attacker some information about $A$, also. Namely, they can create the linear system

$$u = A(A^{-1}u)$$
which is an equation with $n^2$ unkowns ($A$) and $n$ equations. So, asking the signature from the prover $n$ times gives the attacker $n^2$ equations, which is enough to derive the secret matrix $A$. Even though this is also a vulnerability, it would never be useful for an attacker since the first vulnerability we just showed will give them all secret matrices from just one round of the signature.
## Using the technique demonstration
We now use the technique described in the research chapter and show the correctness of the technique experimentally
```
sage: u, C = find_corank1_pt_T()
sage: A = random_matrix(n)
sage: B = random_matrix(n)
sage: M = random_matrix(n)

sage: D = new_tensor_from_tensor_and_isomorphism(C, A, B, M)

sage: LU, LV, LW = corank_1_to_3vector_tuples(u, C, std_dir=True)
sage: LUD, LVD, LWD = corank_1_to_3vector_tuples(A.inverse()*u, D, std_dir=True)

sage: f,g,h = create_fgh(create_phi_head(LU,LV,LW,Tensor2.GaloisTensorMap(C)))
sage: C_prime = new_tensor_from_tensor_and_isomorphism(C, LU*diagonal_matrix(f), LV*diagonal_matrix(g), LW*diagonal_matrix(h))

sage: fD,gD,hD = create_fgh(create_phi_head(LUD,LVD,LWD,Tensor2.GaloisTensorMap(D)))

sage: C_prime_hyp = new_tensor_from_tensor_and_isomorphism(D, LUD*diagonal_matrix(fD), LVD*diagonal_matrix(gD), LWD*diagonal_matrix(hD))

# we want C_prime and C_prime_hyp to be equal
sage: tensor_equality(C_prime, C_prime_hyp)
True
```
We also show that both $C_{prime}$ and $C_{prime\_hyp}$ are 1 in the correct entries:

```sage: C_prime
array([[[0, 0, 0, 0, 0, 0, 0, 0],
        [1, 0, 1, 1, 1, 1, 1, 1],
        [1, 1, 0, 380, 387, 395, 21, 77],
        [1, 350, 35, 0, 93, 199, 366, 296],
        [1, 243, 50, 65, 0, 189, 318, 101],
        [1, 357, 233, 284, 75, 0, 254, 96],
        [1, 376, 412, 294, 205, 382, 0, 9],
        [1, 289, 120, 156, 202, 340, 297, 0]],

       [[0, 1, 142, 119, 374, 46, 196, 299],
        [0, 0, 0, 0, 0, 0, 0, 0],
        [0, 146, 0, 269, 1, 368, 290, 403],
        [0, 305, 59, 0, 378, 385, 386, 288],
        [0, 246, 105, 52, 0, 134, 50, 357],
        [0, 341, 377, 375, 161, 0, 383, 367],
        [0, 102, 282, 83, 368, 362, 0, 311],
        [0, 60, 317, 326, 274, 301, 95, 0]],

       [[0, 0, 407, 217, 293, 356, 419, 237],
        [1, 0, 247, 286, 251, 50, 348, 341],
        [0, 0, 0, 0, 0, 0, 0, 0],
        [374, 0, 234, 0, 130, 349, 329, 204],
        [114, 0, 381, 313, 0, 64, 113, 404],
        [53, 0, 133, 248, 97, 0, 342, 169],
        [194, 0, 109, 139, 207, 357, 0, 255],
        [129, 0, 10, 33, 152, 180, 205, 0]],

       [[0, 12, 0, 266, 245, 267, 175, 401],
        [1, 0, 0, 271, 33, 26, 1, 47],
        [22, 297, 0, 80, 193, 81, 381, 236],
        [0, 0, 0, 0, 0, 0, 0, 0],
        [287, 145, 0, 196, 0, 34, 332, 398],
        [170, 245, 0, 358, 315, 0, 364, 366],
        [82, 141, 0, 54, 220, 196, 0, 43],
        [356, 362, 0, 359, 97, 255, 395, 0]],

       [[0, 328, 25, 0, 92, 11, 235, 90],
        [1, 0, 383, 0, 389, 280, 39, 356],
        [276, 161, 0, 0, 255, 287, 77, 340],
        [283, 152, 38, 0, 207, 7, 321, 140],
        [0, 0, 0, 0, 0, 0, 0, 0],
        [313, 93, 370, 0, 33, 0, 165, 234],
        [40, 344, 276, 0, 123, 116, 0, 134],
        [2, 301, 106, 0, 58, 218, 318, 0]],

       [[0, 20, 406, 83, 0, 262, 317, 408],
        [1, 0, 108, 45, 0, 33, 328, 218],
        [211, 97, 0, 338, 0, 411, 220, 163],
        [129, 148, 121, 0, 0, 41, 61, 12],
        [225, 389, 343, 28, 0, 270, 152, 126],
        [0, 0, 0, 0, 0, 0, 0, 0],
        [202, 156, 52, 318, 0, 360, 0, 405],
        [41, 105, 19, 241, 0, 203, 265, 0]],

       [[0, 182, 157, 360, 135, 0, 401, 33],
        [1, 0, 174, 181, 248, 0, 404, 164],
        [8, 180, 0, 111, 26, 0, 14, 368],
        [364, 345, 210, 0, 177, 0, 194, 348],
        [356, 54, 223, 116, 0, 0, 397, 128],
        [342, 16, 203, 297, 54, 0, 313, 358],
        [0, 0, 0, 0, 0, 0, 0, 0],
        [125, 353, 116, 285, 206, 0, 20, 0]],

       [[0, 373, 185, 131, 72, 59, 0, 234],
        [1, 0, 80, 246, 197, 155, 0, 29],
        [303, 148, 0, 324, 142, 51, 0, 186],
        [232, 72, 24, 0, 335, 362, 0, 212],
        [344, 33, 344, 142, 0, 324, 0, 160],
        [350, 318, 9, 342, 153, 0, 0, 217],
        [286, 397, 62, 56, 146, 113, 0, 66],
        [0, 0, 0, 0, 0, 0, 0, 0]]], dtype=object)
```

```sage: C_prime
array([[[0, 0, 0, 0, 0, 0, 0, 0],
        [1, 0, 1, 1, 1, 1, 1, 1],
        [1, 1, 0, 380, 387, 395, 21, 77],
        [1, 350, 35, 0, 93, 199, 366, 296],
        [1, 243, 50, 65, 0, 189, 318, 101],
        [1, 357, 233, 284, 75, 0, 254, 96],
        [1, 376, 412, 294, 205, 382, 0, 9],
        [1, 289, 120, 156, 202, 340, 297, 0]],

       [[0, 1, 142, 119, 374, 46, 196, 299],
        [0, 0, 0, 0, 0, 0, 0, 0],
        [0, 146, 0, 269, 1, 368, 290, 403],
        [0, 305, 59, 0, 378, 385, 386, 288],
        [0, 246, 105, 52, 0, 134, 50, 357],
        [0, 341, 377, 375, 161, 0, 383, 367],
        [0, 102, 282, 83, 368, 362, 0, 311],
        [0, 60, 317, 326, 274, 301, 95, 0]],

       [[0, 0, 407, 217, 293, 356, 419, 237],
        [1, 0, 247, 286, 251, 50, 348, 341],
        [0, 0, 0, 0, 0, 0, 0, 0],
        [374, 0, 234, 0, 130, 349, 329, 204],
        [114, 0, 381, 313, 0, 64, 113, 404],
        [53, 0, 133, 248, 97, 0, 342, 169],
        [194, 0, 109, 139, 207, 357, 0, 255],
        [129, 0, 10, 33, 152, 180, 205, 0]],

       [[0, 12, 0, 266, 245, 267, 175, 401],
        [1, 0, 0, 271, 33, 26, 1, 47],
        [22, 297, 0, 80, 193, 81, 381, 236],
        [0, 0, 0, 0, 0, 0, 0, 0],
        [287, 145, 0, 196, 0, 34, 332, 398],
        [170, 245, 0, 358, 315, 0, 364, 366],
        [82, 141, 0, 54, 220, 196, 0, 43],
        [356, 362, 0, 359, 97, 255, 395, 0]],

       [[0, 328, 25, 0, 92, 11, 235, 90],
        [1, 0, 383, 0, 389, 280, 39, 356],
        [276, 161, 0, 0, 255, 287, 77, 340],
        [283, 152, 38, 0, 207, 7, 321, 140],
        [0, 0, 0, 0, 0, 0, 0, 0],
        [313, 93, 370, 0, 33, 0, 165, 234],
        [40, 344, 276, 0, 123, 116, 0, 134],
        [2, 301, 106, 0, 58, 218, 318, 0]],

       [[0, 20, 406, 83, 0, 262, 317, 408],
        [1, 0, 108, 45, 0, 33, 328, 218],
        [211, 97, 0, 338, 0, 411, 220, 163],
        [129, 148, 121, 0, 0, 41, 61, 12],
        [225, 389, 343, 28, 0, 270, 152, 126],
        [0, 0, 0, 0, 0, 0, 0, 0],
        [202, 156, 52, 318, 0, 360, 0, 405],
        [41, 105, 19, 241, 0, 203, 265, 0]],

       [[0, 182, 157, 360, 135, 0, 401, 33],
        [1, 0, 174, 181, 248, 0, 404, 164],
        [8, 180, 0, 111, 26, 0, 14, 368],
        [364, 345, 210, 0, 177, 0, 194, 348],
        [356, 54, 223, 116, 0, 0, 397, 128],
        [342, 16, 203, 297, 54, 0, 313, 358],
        [0, 0, 0, 0, 0, 0, 0, 0],
        [125, 353, 116, 285, 206, 0, 20, 0]],

       [[0, 373, 185, 131, 72, 59, 0, 234],
        [1, 0, 80, 246, 197, 155, 0, 29],
        [303, 148, 0, 324, 142, 51, 0, 186],
        [232, 72, 24, 0, 335, 362, 0, 212],
        [344, 33, 344, 142, 0, 324, 0, 160],
        [350, 318, 9, 342, 153, 0, 0, 217],
        [286, 397, 62, 56, 146, 113, 0, 66],
        [0, 0, 0, 0, 0, 0, 0, 0]]], dtype=object)
```
We see that both tensors are equal, and are 1 in the predetermined entries.
